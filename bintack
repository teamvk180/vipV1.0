Expression *Parser::expr()
{
    Expression *t = nullptr;
    if (match(type::RPAR) || match(type::SEMICOLON))
    {
        cout << "expr " << currentToken.lexeme << endl;
    }
    else
    {
        BunddleExpr *l = new BunddleExpr();
        l->expr_.push_back(this->parseExpr());
        while (match(type::COMMA))
        {
            next();
            l->expr_.push_back(this->parseExpr());
        }
        return l;
    }
    return t;
}

Expression *Parser::parseExpr()
{
#ifdef DEBUG
    std::cout << currentToken.lexeme << " >> type : " << (int)currentToken.token_type << "\tparseExpr" << std::endl;
#endif
    BunddleExpr *b = new BunddleExpr();
    Expression *lhs = nullptr;
    while (!isInvalid(currentToken.token_type))
    {
        lhs = this->parseTerminal();
        ALExpr *p = new ALExpr();
        if (isValid(currentToken.token_type))
        {

            p->lhs = lhs;
            p->op = currentToken.token_type;
            next();
            p->rhs = parseTerminal();
        }
        else if (isInvalid(currentToken.token_type))
        {
            return p;
            break;
        }
        else
        {
            cerr << "invalid symbol " << (int)currentToken.token_type << endl;
            break;
        }

        b->expr_.push_back(p);
    }

    return b;
}

// static
Expression *Parser::parseTerminal()
{
#ifdef DEBUG
    std::cout << currentToken.lexeme << " >> type : " << (int)currentToken.token_type << "\tparseTerminals" << std::endl;
#endif
    next();
    BunddleExpr *l = new BunddleExpr();
    if (match(type::LPAR))
    {
        l->expr_.push_back(this->expr());
        eval(type::RPAR, "expected ')'");
    }
    else if (match(type::INT))
    {
        staticExpr *s = new staticExpr;
        s->mToken = currentToken;
        next();
        l->expr_.push_back(s);
    }
    else if (match(type::CHAR))
    {
        staticExpr *s = new staticExpr;
        s->mToken = currentToken;
        next();

        l->expr_.push_back(s);
    }
    else if (match(type::STRING))
    {
        cout << "string detected" << endl;
        staticExpr *s = new staticExpr;
        s->mToken = currentToken;
        next();
        cout << "rnext is " << currentToken.lexeme << endl;
        l->expr_.push_back(s);
    }
    else if (match(type::TRUE))
    {
        staticExpr *s = new staticExpr;
        s->mToken = currentToken;
        next();

        l->expr_.push_back(s);
    }
    else if (match(type::FALSE))
    {
        staticExpr *s = new staticExpr;
        s->mToken = currentToken;
        next();

        l->expr_.push_back(s);
    }
    else if (match(type::THIS))
    {
        staticExpr *s = new staticExpr;
        s->mToken = currentToken;
        next();
        l->expr_.push_back(s);
    }
    else if (match(type::VOID))
    {
        staticExpr *s = new staticExpr;
        s->mToken = currentToken;
        next();

        l->expr_.push_back(s);
    }
    else
    {
        //not a terminal ie a symbol
        l->expr_.push_back(this->parseExpr());
    }
    return l;
}
